[[rc-core]]
== Requirements Class "Core"

=== Overview
The requirements described in this section define the symbology core requirement class. The UML diagram (<<img-uml-class>>) shows the fundamental concepts of the Symbology Conceptual and Logical Model.

[#img-uml-class-core]
.UML Class Diagram of the Symbology core
include::../UML/PlantUML/adoc/core.adoc[]

==== Styles

A Style is the root concept of the Styles and Symbology Conceptual Model and consists of an ordered list of StylingRules.
The StylingRules are to be applied in order so that rules selected later override earlier ones.
This allows to compose styles in a cascading manner by inheriting from a base style then overriding some specific portrayal behaviors.

////
This class organizes the rules of symbolizing instructions to be applied by a rendering engine on a layer of geographic features
(e.g., vector based spatial data or raster data).

Please note that the graphic pipeline of the rendering engine must be expressed unambiguously for each concrete implementation of a Style in order to enable cartographic portrayal interoperability.
////

////
Can we omit this metadata? This might belon instead to the encoding or styles metadata.

| name	   | A string value to reference the Style	| ParameterValue data type	| Zero or one
| title	   | Human readable title	| ParameterValue data type	| 0..1
| abstract	| Human readable description	| ParameterValue data type	| 0..1
////

.Style
[width="90%",options="header"]
|===
| Name	      | Definition	                     | Data type and value | Multiplicity
| stylingRules | Styling rules defining the style	| StylingRule         | 0..n
|===

==== Styling Rules

A StylingRule specifies that a particular Symbolizer (defining how to portray data) should be applied if the rule is selected based on a Selector expression (e.g., feature-property conditions or map scales).
A StylingRule can contain nested rules, which will only be applied if the the parent rule's Selector is evaluated to true, and whose Symbolizers will inherit from and override the parent StylingRule's Symbolizer.

////
Do we need these?

| title	| Human readable title	| ParameterValue data type	| One
| abstract	| Human readable description	| ParameterValue data type	| Zero or one
////

////

Internationalization support would be great.
Where exactly do we need this?
The following was in ParameterValue, but most parameter values will be numbers/colors, or feature/covergge properties.
What actually needs i18n? Rule labels for legends? The choice between feature properties available in different languages?

| language	| Language identifier for the ParameterValue element. (a)	| Character String. This language identifier shall be as specified in IETF RFC 4646.	| zero or more
(a) The language identifier should offer a way to adapt the ParameterValue to a specified language, e.g., display the title of a Rule element both in English and French.
////

.StylingRule
[width="90%",options="header"]
|===
| Name	      | Definition	                                                   | Data type and value	   | Multiplicity
| name      	| A name for the rule (useful for generating legends)             | string                   | 0..1
| selector  	| Selector defining the condition to apply the rule's symbolizer	| Expression	            | 0..1
| symbolizer	| Symbolize(s) to apply by the rendering engine	                  | Symbolizer	            | 1
| nestedRules  | Symbolize(s) to apply by the rendering engine	                  | StylingRule              | 0..n
|===

The selector (also sometimes called a _filter_), for the rule is defined as a predicate expression evaluating to either true or false.

==== Symbolizers

A Symbolizer describes how to portray geographic data (e.g., vector features or gridded coverage data) based on a set of properties.
This core requirements class only defines three basic properties relevant to most portrayal use cases.
Separate requirements classes and later parts will extend this Symbolizer class with additional properties to provide more advanced portrayal capabilities.

////
| name	| A string value to reference the Symbolizer	| ParameterValue data type	| Zero or one
| title	| Human readable title	| ParameterValue data type	| One
| abstract	| Human readable description	| ParameterValue data type	| Zero or one
| uom	| Unit of measure to apply to all graphical properties of a Symbolizer	| uom code	| Zero or one
////

.Symbolizer
[width="90%",options="header"]
|===
| Name	     | Definition	                | Data type and value  | Multiplicity
| visibility | Whether to display the data  | bool                 | 0..1
| opacity    | Degree of opacity            | float                | 0..1
| zOrder     | Specify a rendering order    | int                  | 0..1
|===

////
-- I don't think we need the following explanation anymore:

To understand what the symbolizer concept is, consider a “Lake” feature type represented by a Polygon that is to be symbolized as a “blue” filled polygon with its boundary drawn with a “black” stroke.
As symbolizer is an abstract class: a concrete extension called here, for example, AreaSymbolizer, which must be provided to render an interior “fill” and an outlining “stroke.”
Consequently, the AreaSymbolizer extension will implement concrete extensions of the abstract Stroke and Fill classes of the conceptual model.

Depending on the type of geographical object, a set of symbolizer extensions can be conceived. For example a LineSymbolizer to draw a river, a PointSymbolizer to represent the “Hospitals,” or a
LabelSymbolizer to render the road name along a line.
////

==== Expressions

Expressions are a syntactic entity that may be evaluated to determine its value (from https://en.wikipedia.org/wiki/Expression_(computer_science)[Wikipedia]).
The concept has similar meaning to Expressions as defined in the OGC Filter Encoding 2.0 standard, and can also be implemented with the OGC Common Query Language (CQL2),
with the caveat that the Expressions defined here are not restricted to evaluate to a boolean value as is the case for the first version of CQL2.

Expressions can be used in two places according to this Styles & Symbology conceptual model: as a Selector defining the condition whether to apply a StylingRule or not, as well
as to define the values of Symbolizer properties.

[#img-uml-class-expressions]
.UML Class Diagram of the Symbology Expressions
include::../UML/PlantUML/adoc/expressions.adoc[]

===== Parameter Values

The use of an expression as a Symbolizer property is called a _Parameter Value_, where an Expression can be substituted
where a particular data type is expected, in which case the Expression will be resolved to that expected data type.
Conceptually, all Symbolizer properties can be specified using any type of expression _Parameter Value_, but this is not required by
this core conformance class, and specific requirements classes such as the "Symbolizer Parameter Value Expresssions"
requirements class enable this behavior. Without a requirements class specifying otherwise, only <<literal-expressions,Literal Expressions>>
compatible with the expected data type are allowed as _Parameter Values_.

===== Identifier Expressions

An Identifier Expression is represented by a textual property that gets resolved at runtime.

Typical example of identifier expresions include feature properties (e.g., `population`) and coverage range values (e.g., a particular imagery band `B8`).

One specific type of identifier expressions use System Identifiers.
A System Identifier refers to an internal state of the system, or a particular aspect of the data being portrayed.

The following System Identifiers are defined by this conformance class:

////
TOCHECK: How to handle parent objects ? e.g.,  visualization, dataLayer, feature
////

.Visualization System Identifiers
[width="90%",options="header"]
|===
| Name                          	| Definition	                          | Data type and value
| visualization.scaleDenominator	| Current visualization scale denominator | float
| visualization.dateTime            | Current visualization date and time     | DateTime
| visualization.date                | Current visualization date              | Date
| visualization.timeOfDay           | Current visualization time of day       | Time
|===

.Layer System Identifiers
[width="90%",options="header"]
|===
| Name                          	       | Definition	                                             | Data type and value
| dataLayer.identifier          	       | Identifier of data layers                                | string
| dataLayer.type                        | Data type of data layers                                 | enumeration: vector, coverage, ...
|===

////
TODO: In other req classes:

* dataLayer.features                    -- for advanced comparison of feature against all other features
* dataLayer.featuresGeometry            -- for advanced comparison of feature against all other features
* feature.geometry                      -- for spatial operators
////

[[literal-expressions]]
===== Literal Expressions

A literal expression is an expression that has a fixed value in the encoding of the style.
A similar literal class concept was originally defined in the OGC Filter Encoding 2.0 standard section 7.5.1.

The following types of literals are defined:

* An integer literal represents a whole numeric value
* A real literal represents a real number (integer, fractional or irrational number)
* Text literals are Unicode character strings
* A `null` literal represents an unset value
* Enumeration value literals allow to refer by name to a set of pre-defined values associated with the context where they are used
* Boolean literals are a specialized type of enumeration literals which are either `true` or `false`
* Array literals (see <<array-expressions,Array Expressions>>)
* Instance literals (see <<instance-expressions,Instance Expressions>>)

===== Operation Expressions

An Operation Expression performs an operation specified by an Operator on one, two or three operand expressions, depending on whether they unary, binary or ternary operators.
This core requirements class defines only Logical and Relational operators.
Implementations are also required to support prioritizing operations (typically encoded using parentheses: `(` `)`).
Other requirements classes introduce support for additional operators for arithmetic, text and bitwise operations.

This requirements class defines the following Logical Operators :

.Logical Operators
[width="90%",options="header"]
|===
| Name                     | Symbol    | Type   | Definition
| not                      | `not`     | unary  | True if and only if the operand is false
| and                      | `and`     | binary | True if and only if both operands are true
| or                       | `or`      | binary | True if and only if either or both of the operands is true
|===

This requirements class defines the following Relational Operators:

.Relational Operators
[width="90%",options="header"]
|===
| Name                     | Symbol                |Type     | Definition
| equalTo                  | `=`                   |binary   | The first operand is equal to the second one
| notEqualTo               | `<>`                  |binary   | The first operand is not equal to the second one
| is (null)                | `is`                  |binary   | Only used with `null` literal for second operand (the first operand is null)
| isNot (null)             | `is not`              |binary   | Only used with `null` literal for second operand (the first operand is not null)
| smallerThan              | `<`                   |binary   | The first operand is smaller than the second one
| greaterThan              | `>`                   |binary   | The first operand is greater than the second one
| smallerOrEqual           | `\<=`                 |binary   | The first operand is smaller than or equal to the second one
| greaterOrEqual           | `>=`                  |binary   | The first operand is greater than or equal to the second one
| in (array)               | `in`                  |binary   | Only used with an array for second operand (the first operand is one of the elements of the array)
| notIn (array)            | `not in`              |binary   | Only used with an array for second operand (the first operand is not one of the elements of the array)
| between                  | `between ... and`     |ternary  | The first operand is between the second and third operands (inclusively)
| notBetween               | `not between ... and` |ternary  | The first operand is not between the second and third operands (inclusively)
|===

[[array-expressions]]
===== Array Expressions

An array expressions defines zero, one, or more element expressions forming an ordered set.

An _array literal_ is a special type of array expression whose elements are all literals.

[[instance-expressions]]
===== Instance Expressions

An instance expressions instantiates an object of a class while optionally specifying values for member components.
The default values for any member if not explicitly overridden can is specified by the class member definitions.

An _instance literal_ is a special type of instance expression assigning only literal expressoins to its member components.

A Symbolizer may either set an object property with a complete new instance, or specifically override a particular member of that object property.
This capability is particularly useful when using nested StylingRules, where a nested rule can inherit the Symbolizer from the parent StylingRule.

=== Requirements

include::../requirements/rc-core.adoc[]
